---
tag: "mysql, InnoDB"
date: "2020-12-29 15:58"
---

# InnoDB

> [官方文档](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html)
> [美团](https://tech.meituan.com/2014/08/20/innodb-lock.html)

## Locking Readings

> [锁读](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html)

## 并发写问题

> [CSDN](https://www.cnblogs.com/fengzheng/p/12557762.html)

- 在并发写同一行数据时，如果 where 条件字段没有加索引，innodb 会对所有行加行锁，再对条件进行筛选，不符合条件的行再释放锁。一锁一放损耗极大，所以建议适当添加索引。

## 事务隔离级别

事务三种隐患

1. 脏读，事务A读到其他事务B未提交的内容，B中数据回滚或其他更新后，A就会读到脏数据。
2. 不可重复读，事务A分别在事务B（更改了数据）提交前后的数据，发现数据前后不一致。
3. 幻读，事务A读事务B（新插入了数据）提交后，发现前面读到的数据比之后读到的数据少了一部分。

### InnoDB 隔离级别

可以设置全局，也可以设置到 session ，设置后开启新的 session 即可生效。

1. 读未提交，事务未提交就可以读到数据更新，不能阻止以上三种任何隐患，直接读取事务中修改后的值，没有视图概念。
2. 读已提交，事务提交后才去读。事务在执行每一条查询前都会查询结果放到事务的视图中，可以防止脏读，不能防止不可重复读与幻读
3. 可重复读，事务在执行语句之初就去读取需要查询的数据并放在视图中，在事务提交之前保存之前都不更新此视图（**新插入的数据还是会再读取到视图中**）。所以这样可以防止不可重复读，不能防止幻读。
4. 串行化，事务之间排队执行，防止一切隐患。
