---
layout: "post"
title: "network protocol"
date: "2018-12-29 15:04"
---

> 趣谈网络协议

## 一个简单的网络请求之路

1. 请求数据
2. **应用层** 加上 HTTP 头（应用层包括：HTTP HTTPS DNS）
3. **传输层** 加上 TCP 头，其中包括 请求客户端与目标服务器的 端口号信息
4. **网络层** 加上 IP 头，内容为 双方的 IP 地址
5. **MAC 层** 加上 MAC 头，内容为双方的 mac 地址

### Q&A

- 一个普通的网络请求会经过多少个网关？每一个网关都会有不同的 ip 吗？如果有，是不是每经过一个网关是不是都会被一整套函数给拆封与封装一次呢？

## OSI模型

- 概念：Open System Interconnect，开放式系统互联
  - 这个模型把网络通信的工作分为7层：
    - 由低到高：物理层（Physical Layer），设备：中继器，集线器，单位：比特（bit）
    - 数据链路层（Data Link Layer)，设备：二层交换机、网桥，单位：帧（frame)
    - 网络层（Network Layer)，设备：路由器，单位：数据包（packet)，相关：ip地址、数据包、路由协议、ARP（地址解析协议）
    - 传输层（Transport Layer)，提供端到端的透明数据传输服务，单位：数据包（packets)
    - 会话层（Session Layer)，建立访问验证会话管理在内的建立维护应用之间通信的机制
    - 表示层（Presentation Layer)，格式化的表示和转换数据服务，数据的压缩与解压，加密与解密
    - 应用层（Application Layer)，操作系统或网络应用程序提供访问网络服务的接口，此层协议就包括了：Http,FTP,SNMP,Telnet
  - 低三层负责创建通信连接的链路，高四层负责端到端的数据通信；
  - 网络通信在发送端自上而下，在接收端自下而上依层进行；但也不一定要经过全七层，比如：中继器之间的连接只需要在物理层中进行，而路由器之间的连接只需通过下三层；
  - 但双方端端之间的通信必须是对等的，不可能存在不对等层次间的通信（也就是在发送端通过了哪些层，在接收端也要反序通过这些层）；

## TCP/IP模型

> OSI系统只是提供了网络通信的模型，实际应用中，我们使用的最成熟最广的互联协议是TCP/IP模型基础上建立的，它相对于OSI模型更为精简；
> TCP：传输控制协议（Transport Control Protocol)
> IP：Internet Protocol，网络协议
> UDP：User Datagram Protocol,用户数据包协议

**分为四层：**

- 网络访问层：对应OSI的物理层+数据链路层
- Internet层：对应OSI网络层
- 传输层：对应OSI的传输层
- 应用层：对应OSI的会话层、表示层、应用层

### TCP的三次握手

- TCP的三次握手是为了保证数据通信时安全性，确保请求方与响应方是正确对应的。
- 通俗用一个发送机密文件的例子来理解：
  - 发送方为确保机密，先将文件上锁寄给接收方，接收方收到文件后再上一把自己的锁并将这个上过两次锁的文件再寄给发送方，发送方收到后将自己的锁解掉，再寄给接收方，这时接收方就可以收到只有自己的锁的文件了；
- 那么在TCP协议中，这个三次握手过程是怎么实现的？
  - **第一次握手**：请求方先发送位码：syn=1,随机产生seq number=200的数据包到响应方（服务器），这时接收方由syn=1得知发送方要求实现同步联机；
  - **第二次握手**：响应方收到请求联机后，要确认此信息，便向发送方发送ack number=(seq+1),syn=1,ack=1,再随机产生seq number=500的包；
  - **第三次握手**：发送方收到来自接收方的数据包，检查接收到的数据中`ack number`是不是与自己刚才发送的随机码`(seq nubmer+1)`相等，以及位码ack是不是为`1`，如果两项无误证明是自己需要的对方，便再发送`ack number=(刚收到来自响应方的seq number+1)`，`ack=1`，响应方确认`seq number`值无误与`ack=1`，便可以确认连接建立成功，三次握手完成。
  - **Note:**
    - 每一次握手只要需要对就方响应就会随机生成一个序列码：`seq number`,对方收到响应时便在这个序列码基础上进行加`1`，当作响应码`ack number`再返给原来请求方，这样一个过程来确保连接双方无误；
    - 同时，第一次发起请求同步有一个`syn=1`码，这是一个请求同步，发起请求的码；
    - 每次响应，不管是请求方在握手过程中响应响应方还是响应方响应请求，都会有一个`ack=1`码，来确认自己是在应答对方；
    - 第三次握手（即请求方第二次发送）的必要性：在请求方收响应方的一次响应后，**对于请求方来说已经确认自己发送的请求能被响应方收到且能收到响应方的应答，但对于响应方来说不能确认请求方能够正确收到响应的应答**。

### TCP的四次挥手

- TCP的四次挥手是指双方要关闭连接， 这时出现的情况可能是双方任一方发起close请求也可能是双方同时发起；
- 当其中一方发起关闭请求时：
  - **第一次挥手：**请求方发起一个`fin`用来关闭请求方给响应方的数据传送，这时请求方进入到`fin_wait`状态，同时肯定还是要发送随机生成的请求序号；
  - **第二次挥手：**响应方收到`fin`后，发送一个`ACK`给请求方，同时发送确认序号（为收到的请求序号+1），这个时候响应方进入到`CLOSE_WAIT`状态，同时要发送随机序号`seq`；
  - **第三次挥手：**响应方发送一个`FIN`，用来关闭响应方到请求方的数据传送，这时响应方进入到`LAST_ACK`状态，同时要发送随机序号`seq`；
  - **第四次挥手：**请求方收到`FIN`后，进入到`TIME_CLOSE`状态，再发送一个`ACK`给响应方，同时发送确认序号（在随机序号上+1），响应方收到这些信息确认无误，进行到`CLOSED`状态；完成四次挥手；
- 当双方同时发起关闭请求时：
  - **前两次挥手：**双方发送`FIN=1`码，与随机码；
  - **后两次挥手：**双方收到后，再给彼此发送`ACK=1`和`ack number=（随机码+1）`；
- **Note:**
  - `FIN`码发送后，相应的方应该进入到`WAIT`状态或`CLOSE`状态；
  - `ACK`响应码用来指示自己需要得到回复；
  - 还是与握手一样，用来确认双方信息连接的无误都通过随机序码指定的运算；

#### 问题

1. 发送一次请求进行的流程就是：三次握手 -> 传输请求数据 -> 四次挥手？
   1. 还是说：三次握手后，要等整个会话结束（请求完成，再响应完成）才进行四次挥手结束整个流程？
   2. 这个答案是依赖于所谓的 **长链接/短链接** ？
   3. answer: 不依赖是长链接还是短链接，就算是短链接，整个流程也会是在三次握手与四次挥手之间将请求与响应进行完全。[reference](https://www.cnblogs.com/0201zcr/p/4694945.html)

### netcat

网络连接中的“瑞士军刀”。[reference 更多 linux 命令可参考此网站](https://linuxize.com/post/netcat-nc-command-with-examples/)

- 基本语法： `nc [options] host port`，需要指定主机与端口；
- netcat 默认开启 TCP 连接，如果需要 UDP ，加上参数 `-u` :`nc -u host port`
- 扫描主机端口：`nc -z -v host port-range`， `-z` 指定只扫描打开的商品且不发送数据， `-v` verbose 提供详细信息；
  - 如果需要过滤信息可使用管道：`nc -z -v host port-range | grep succeeded`

#### 通过 netcat 传输文件

通过 netcat 创建一个简约的 client/server 模型，从一台主机传输数据到另一台主机。大致思路：通过 netcat 监听接收端指定端口，通过 TCP 建立与另一台主机连接，最后通过此连接发送文件。

1. 监听端口并指定输出文件：`nc -l port > file_name`, `-l` 指 listen，最后数据重定向到指定文件
2. 发送端发送文件：`nc receiving_host port < file_name` 。
3. 使用 CTRL+C 关闭连接。

对于文件夹的传输可以联合使用 tar 命令

- 在发送端可以先压缩再发送：`tar czvf - /path/dir | nc receiving_host poat`;
- 在接收端可以接收后直接解压： `nc -l port | tar xzvf -`

#### 使用 netcat 实现简单地聊天功能

概述：与传输文件一样，只需要一端开放一个端口进行监听，另一端对此主机端口发送信息即可。

1. server 端使用 netcat 监听端口：`nc -l port`;
2. client 端使用 netcat 连接 server 端口： `nc server_host port`;
3. 两端现在都可以输入数据，按 ENTER 将数据发送出去，另一端即可收到对方数据；
4. CTRL+C 断开连接。

#### 使用 netcat 执行一个 HTTP 请求

在 linux 上执行 http 请求有更好用的命令： `curl` ，此处仅作尝试。

使用 netcat 访问 OpenBSD 网站：`printf "GET /nc.1 HTTP1.1\r\nHost: man.openbsd.org\r\n\r\n" | nc man.openbsd.org 80`。执行此命令后，终端将打印出整个响应内容，包括 HTTP headers 和 html 代码。
