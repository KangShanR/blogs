---
layout: "post"
date: "2020-5-14 18:58"
---

# bit operation

计算机的位运算

## 位移运算

在 java 中，右移分为符号右移 `>>`（signed arithmetic right shift）与无符号右移 `>>>`（unsigned, logical right shift）。而左移运算只有 `<<` 一种，因为其逻辑左移与算法左移都是同一种操作并不需要对符号位进行特殊处理。[reference](https://www.quora.com/Why-is-there-no-unsigned-left-shift-operator-in-Java)

在逻辑右移的过程中，计算机并不对首位符号位进行特殊照顾，只是单纯地使用位移操作将所有 bit 向右移即可。而算法右移在这个逻辑右移的操作中还得将左高位填充上符号位上的 bit 。这样的位移才能等于我们的求负幂的运算（除以 2 的 n 次幂）。而对于左移，一个正数的算术左移在不越界的情况下就等于其逻辑左移的效果。负数的左移也是一样（负数绝对值越大，其怎么符号位外的值越小，最大的 int 负数二进制 _12位_ 为： 1000 0000 0000）。

### 关于二进制符号位

观察所得，一个固定 bit 位数的整数，其最大值与最小值在 bit 位上只差 1 bit 。eg(为简便表示，只写 12 位):

Max: 0111 1111 1111
Min: 1000 0000 0000
-1:  1111 1111 1111
0:   0000 0000 0000

- 对于机器来说，对一个最大的数再进行 `+1` 操作就越界到了最小的负数。外界使用时就会看到越界的结果。
- 对于负数来说，其最大绝对值就是符号位首位为1 而其他位都为 0 的数，而只要比这个绝对值小的数都是在此其他上 + 1 。这就也造成了所有负数前面位都为 1 ，所以在左移的过程中越能一直保持符号不变且左移而变大。（不得不说，使用二进制 bit 位来表示数的设计之精妙，机器能减少所有多余的操作）
