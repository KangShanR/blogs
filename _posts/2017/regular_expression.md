---
title: 正则表达式
date: 2017-01-13 12:22:23
categories: programming
tags: programming
description:
---

- 各类计算机语言中提供专门的方法与接口来执行正则表达式（比如：Java 中的 `boolean String.matches(String regex);` 将其作为一个参数,返回这个字符串是否匹配得上这个正则表达式）；
- 正则表达式是对字符串进行逐个字符验证，从第一个字符开始，依次往后匹配，有一个不匹配就可以 over 跳出循环;
- 必须从头判定到尾，如果没有对尾作出判定，表达式会将字符串当作另一个更短的字符串来判定则肯定不匹配；

[参考文档]( http://baike.baidu.com/link?url=AQRTFncrkkeq2AETf8iwcrZNAmWQ2BYslX1pArdFsX6L_Pdq8Z1d62qxJcFm93xDiPHBo2TQOz1orepDMZIiX2veYoC4dNlObqyQCZteR8FrZmqkD2x2ldWsPhe6HqZq_56FS3G3nVD6bef8LDdBHK)

## skills

- 开头： `^` ，`^[a-z]` 就表示使用 a-z 的字母开头
- 非： `^` ， `[^A-z]` 表示匹配非字母的字符
- 结尾： `$` ，`[0-9]$` 表示以 0-9 的数字结尾
- 数字： `\d` 或 `[0-9]`
- 数量： `{m,n}`， `[A-z]{3,5}` 表示大小写字母 3-5 位
  - 0 次或 1 次： `?` ， `0?` 表示出现 `0` 这个字符 1 次或者 0 次
  - 0 次或多次： `*` ， `\d*` 表示数字出现任意次数
  - 至少 1 次： `+` ， `\d+` 表示数字至少出现 1 次
  - m 与 n 是非负整数
  - 其中 `n` 可以为 空，当 `n` 为空时，表示 有 m 次出现及以上出现。
  - 当只有 `m` 时，表示出现 m 次

## 正则表达式中各个字符表达的意义

### 限制符

|元字符|描述|
|:---------:|:---------------|
|`*`|匹配前面的子表达式任意次。例如，`zo*` 能匹配  `z` ，也能匹配 `zo` 以及 `zoo` 。`o*` 等价于 `o{0,}`|
|`+`|匹配前面的子表达式一次或多次(大于等于 1 次）。例如， `zo+` 能匹配 `zo` 以及 `zoo` ，但不能匹配 `z` 。`+` 等价于 `{1,}`。|
|`?`|匹配前面的子表达式零次或一次。例如， `do(es)?` 可以匹配 `do` 或 `does` 中的 `do` 。`?` 等价于`{0,1}`。|
|`?`|当该字符紧跟在任何一个其他限制符 `*`，`+`，`?`，`{n}`，`{n,}`，`{n,m}` 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 `oooo` ，`o+` 将尽可能多的匹配 `o`，得到结果 `oooo`，而 `o+?` 将尽可能少的匹配 `o`，得到结果 ((`o`, `o`, `o`, `o`)，指 4 个 `o`|
|`{n}`|n 是一个非负整数。匹配确定的 n 次。例如， `o{2}` 不能匹配 `Bob` 中的 `o` ，但是能匹配 `food` 中的两个 `o`。|
|`{n,}`|n 是一个非负整数。至少匹配 n 次。例如， `o{2,}` 不能匹配 `Bob` 中的 `o` ，但能匹配 `foooood` 中的所有 `o`。 `o{1,}` 等价于 `o+` 。 `o{0,}` 则等价于 `o*` 。|
|`{n,m}`|m 和 n 均为非负整数，其中 n<=m。最少匹配 n 次且最多匹配 m 次。例如， `o{1,3}` 将匹配 `fooooood` 中的前三个 o 为一组，后三个 o 为一组。 `o{0,1}` 等价于 `o?` 。请注意在逗号和两个数之间不能有空格。|

### 字符指定

|元字符|描述|
|:---------:|:---------------|
|`\`|将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，`\\n` 匹配 `\n`。`\n`匹配换行符。序列 `\\` 匹配 '\' 而 `\(` 则匹配 '(' 。即相当于多种编程语言中都有的 *转义字符* 的概念。|
|`^`|匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，`^` 也匹配 `\n` 或 `\r` 之后的位置。|
|`$`|匹配输入字符串的结束位置。如果设置了 RegExp 对象的 Multiline 属性，$也匹配 `\n` 或 `\r` 之前的位置。|
|`.`|匹配除 `\r\n` 之外的任何 *单个字符* 。要匹配包括 `\r\n` 在内的任何字符，请使用像 `[\s\S]` 的模式。|
|`[xyz]`|字符集合。匹配所包含的任意一个字符。例如，`[abc]` 可以匹配 `plain` 中的 a。|
|`[^xyz]`|负值字符集合。匹配未包含的任意字符。例如，`[^abc]` 可以匹配“plain”中的“plin”。|
|`[a-z]`|字符范围。匹配指定范围内的任意字符。例如，`[a-z]` 可以匹配 `a`到 `z` 范围内的任意小写字母字符。注意：只有连字符在字符组内部时，并且出现在两个字符之间时,才能表示字符的范围；如果出字符组的开头，则只能表示连字符本身。|
|`[^a-z]`|负值字符范围。匹配任何不在指定范围内的任意字符。例如，`[^a-z]` 可以匹配任何不在 `a` 到 `z` 范围内的任意字符。|
|`\b`|匹配一个**单词边界**，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的 `\b` 就是匹配位置的）。例如，`er\b` 可以匹配 `never` 中的 `er` ，但不能匹配 verb 中的 `er`。
|`\B`|匹配**非单词边界**。`er\B` 能匹配 `verb` 中的 `er`，但不能匹配 `never` 中的 `er`。
|`\cx`|匹配由 x 指明的控制字符。`\c` 指 control 。例如，`\cM` 匹配一个 Control-M 或 回车符。`x` 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 `c` 字符。|
|`\d`|匹配一个**数字字符**。等价于 `[0-9]`。grep 要加上 `-P`，perl 正则支持
|`\D`|匹配一个**非数字字符**。等价于 `[^0-9]`。grep 要加上 `-P`，perl 正则支持
|`\f`|匹配一个换页符。等价于 `\x0c` 和 `\cL`。
|`\n`|匹配一个换行符。等价于 `\x0a` 和 `\cJ`。
|`\r`|匹配一个回车符。等价于 `\x0d` 和 `\cM`。
|`\t`|匹配一个制表符。等价于 `\x09` 和 `\cI`。
|`\v`|匹配一个垂直制表符。等价于 `\x0b` 和 `\cK`。
|`\s`|匹配任何**不可见字符**，包括空格、制表符、换页符等等。等价于 `[\f\n\r\t\v]`。
|`\S`|匹配任何**可见字符**。等价于 `[^\f\n\r\t\v]`。
|`\w`|匹配**包括下划线的任何单词字符**。类似但不等价于 `[A-Za-z0-9_]`，这里的"单词"字符使用 Unicode 字符集。
|`\W`|匹配任何 **非单词字符**。等价于 `[^A-Za-z0-9_]`。
|`\xn`|匹配 n ，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如， `\x41` 匹配 `A` 。`\x041` 则等价于 `\x04&1` 。正则表达式中可以使用 ASCII 编码。
|`\num`|匹配 num ，其中 num 是一个正整数。对所获取的匹配的引用。例如， `(.)\1` 匹配两个连续的相同字符。
|`\n`|标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。
|`\nm`|标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。
|`\nml`|如果 n 为八进制数字（0-7），且 m 和 l 均为八进制数字（0-7），则匹配八进制转义值 nml。
|`\un`|匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，`\u00A9` 匹配版权符号 `&copy;`。
|`\p{P}`|小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。中括号内的“P”表示 Unicode 字符集七个字符属性之一：标点字符。其他六个属性：`L`：字母；`M`：标记符号（一般不会单独出现）；`Z`：分隔符（比如空格、换行等）；`S`：符号（比如数学符号、货币符号等）；`N`：数字（比如阿拉伯数字、罗马数字等）；`C`：其他字符。*注：此语法部分语言不支持，例：javascript*。
|`<>`|匹配词（word）的开始 `<` 和结束 `>` 。例如正则表达式 `<the>` 能够匹配字符串 "for the wise" 中的 "the"，但是不能匹配字符串 "otherwise" 中的 "the"。*注意：这个元字符不是所有的软件都支持的。*
|`()`|将 `(` 和 `)` 之间的表达式定义为 “组” （group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 `\1` 到 `\9` 的符号来引用。
|`|`|将两个匹配条件进行逻辑 或（OR）运算。例如：正则表达式 `(him|her)` 匹配 `it belongs to him` 和 `it belongs to her` ，但是不能匹配 `it belongs to them.`。*注意：这个元字符不是所有的软件都支持的。*

### 高可用语法

|元字符|描述|
|:---------:|:---------------|
|`(pattern)`|匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在 VBScript 中使用 SubMatches 集合，在 JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 `\(` 或 `\)`。|
|`(?:pattern)`|获取匹配，匹配 pattern 获取匹配结果。这在使用或字符 `|` 来组合一个模式的各个部分时很有用。例如`industr(?:y|ies)`就是一个比 `industry|industries` 更简略的表达式。
|`(?=pattern)`|非获取匹配，正向肯定预查，在任何匹配 pattern 的字符串开始处匹配查找字符串，**该匹配不需要获取供以后使用**。例如，`Windows(?=95|98|NT|2000)` 能匹配 `Windows2000`中的“Windows”，但不能匹配“Windows3.1”中的 `Windows` 。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。*不懂这一句*
|`(?<=pattern)`|非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如: `(?<=95|98|NT|2000)Windows` 能匹配 “2000Windows” 中的 “Windows” ，但不能匹配 “3.1Windows” 中的 “Windows” 。
|`(?!pattern)`|非获取匹配，正向否定预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。
|`(?<!pattern)` |非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如： `(?<!95|98|NT|2000)Windows` 能匹配 `3.1Windows` 中的“Windows”，但不能匹配 “2000Windows” 中的 “Windows” 。

## 案例

1. 匹配某些指定字符同时又不包含某些指定字符 [reference](https://blog.csdn.net/thewindkee/article/details/52785763)
   1. `^((?<!abc).)*admin((?!abc).)*$` 包含 admin 且不包含 abc 。
      1. eg: `abcaadmin`
      2. eg: `absadminac`
