---
title: HTTP 协议的理解与认识
date: 2017-05-06 09:54:30
categories: programming
tags: [programming,HTTP,协议]
keywords: 
---

- 概念：
  - http：hyper text transfer protocol，超文本传协议，其设计之初的目的只是提供一种接收和发布html页面的方法；
  - 用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。
  - HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。*所谓无状态协议，是指这一次客户端的请求与上一次的请求无关。*
  - **Http协议的主要特点：**
    - 支持客户端/服务器模式（cs模式）；
    - **简单快速：**客户端向服务器发送请求服务时，只需传送请求方法与路径。**常用的请求方法：GET、POST、HEAD、PUT、DELETE等；**
    - **HTTP协议简单**，这也便利HTTP服务器的程序规模小，通信速度快；
    - **灵活**，HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记；
    - **无连接**，限制每次连接只处理一个服务器处理完客户的请求，并收到客户的应答后，即断开连接。这样也更节省时间；
    - **无状态：**对于事务的处理没有记忆能力，这也意味着如果后续处理需要前面的信息，它必须重传
    - **明文传输**，不支持加密处理，所以在安全性方面是硬伤。目前解决这一安全问题的方法是使用HTTPS协议；
<!--more-->

- **http的post和get方法性能上的区别：**
  - get是从服务器上获取数据，post是向服务器传送数据。
  - get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。
  - 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。
  - get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。
  - get安全性非常低，post安全性较高。但是执行效率却比Post方法好。
  - 因此建议：
    - get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；
    - 在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；

## web交互过程

- 简单地讲，浏览器与服务器交互过程就是由请求与响应组成，而这个请求的发送与响应的接收就是使用HTTP协议来时行；
- 当请求被发送出去后：
  - 如果请求的是一个**静态的HTML页面**，服务器不做任何处理，直接将该页面文件从服务器端的硬盘中读取到内存交将其响应给客户端，交由浏览器来解析和处理HTML与JS；
  - 如果请求的是一个web交互过程（ASP、JSP、PHP），则该类脚本将由服**务器的脚本处理引擎解析处理完成后将其转换成标准的HTML页面**再响应给客户端的浏览器来处理。
- **当我们访问一个网页时：**如：http://www.baidu.com
  - 这个网址包含四个部分的内容：
    - **协议类型：**`http`，如果访问的是一个FTP网站，则url前缀应该是`ftp`；
    - **主机名：**这里的`www.baidu.com`，也可以是ip地址，两者是等价的，但我们对于IP地址往往不容易记住，就像身份证之于我们本人一样，所以常用域名来表示；这个例子中的顶级域名是：`baidu.com`，而`www`只是子域名，其下面还有`tieba.baidu.com`等都是子域名；
    - **端口号**，端口号之于url就像房间号之于大楼，我们寄一封信给某人，在指定域名后，再指定端口就是指定大楼后再加上门牌号。指定主机名后，请求就行到达这个网卡，但一个网卡上可以指定`0~65535`(2的16次方）个端口，一个端口对就是个服务；
      - **端口的管理是由TCP/IP协议决定的**，在`0~1024`这一批端口是由知名的服务占用，比如：系统中觉的服务；
        - **常用的端口：**
          - HTTP协议：80
          - FTP协议：21
          - SSH协议：22
          - MySql数据库：3306
          - SQLServer数据库：1433
          - Oracle数据库：1521
        - 这也是我们常常访问某个网址并没有输入端口号的原因，我们使用了默认的端口号来建立健全连接；
    - **页面文件**，我们在访问百度首页时，并没有指定页面文件而我们得到了一个页面，原因在于在这个文件夹下我们指定了一个默认的页面，诸如：index.html/index.php/default.asp之类的文件。在web系统中，`/`表示根目录，再往下一层也使用`/`来分隔；
      - *我们最终都是请求这类型的页面文件，最终我们在浏览器上看到的都是此类的文件，只不过我们常常请求的动态页面是由服务器来生成的，最终交给浏览器来显示；*
    - **附加部分（URL地址参数）：**
      - 一个标准的URL地址是前四部分，如果我们请求页面显示`404`，说明这个URL在服务器上不存在或没有生成访页面或者路径有误(总的来说，就是url前四部分有误，只要有误就是404）。**但我们在确保前四部分无误的情况下，要以自定义第五部分，附加的参数，这一部分有误不会影响页面的请求（最典型的sql注入就是通过url地址）**
      - 使用`？`连接前四部分，参数之间使用`&`分隔：`http://china.huanqiu.com/article/2017-09/11232393.html?from=bdwz`

### HTTP 状态码

> HTTP status code 关于HTTP协议使用过程中常遇到的状态码与其代表的意义

**常见的4个HTTP的状态码：**

- 200：请求成功
- 301：资源被永久地转移到其他 URL
- 302：重定向到其他资源，此时响应头中有 Location 字段
- 304：已有资源，直接拿缓存
- 404：请求的资源不存在
- 500：内部服务器错误

**HTTP状态码分类：**

|分类|分类描述|
|:------:|:------|
|1**|信息，服务器收到请求需要请求者继续操作|
|2**|成功，操作被成功并处理|
|3**|重定向,需要进一步操作以完成请求|
|4**|客户端错误,请求包含语法错误或完成请求|
|5**|服务器错误，服务器在请求过程中发生了错误|

**Note:**常见的分类如上，在编码过程中Tomcat返回状态码时，就可以根据状态码大致判定下 bug 在哪里了。

我的问题：这个状态码是服务器返回的，那么 当返回 304 时，服务器根据请求时 cookie 来判定这个响应内容是否已经缓存在客户端了？

### 数据

> 通过抓请求包与响应包可以看到

请求头中

- referer 指请求来源页面地址

## OSI模型

- 概念：Open System Interconnect，开放式系统互联
  - 这个模型把网络通信的工作分为7层：
    - 由低到高：物理层（Physical Layer），设备：中继器，集线器，单位：比特（bit）
    - 数据链路层（Data Link Layer)，设备：二层交换机、网桥，单位：帧（frame)
    - 网络层（Network Layer)，设备：路由器，单位：数据包（packet)，相关：ip地址、数据包、路由协议、ARP（地址解析协议）
    - 传输层（Transport Layer)，提供端到端的透明数据传输服务，单位：数据包（packets)
    - 会话层（Session Layer)，建立访问验证会话管理在内的建立维护应用之间通信的机制
    - 表示层（Presentation Layer)，格式化的表示和转换数据服务，数据的压缩与解压，加密与解密
    - 应用层（Application Layer)，操作系统或网络应用程序提供访问网络服务的接口，此层协议就包括了：Http,FTP,SNMP,Telnet
  - 低三层负责创建通信连接的链路，高四层负责端到端的数据通信；
  - 网络通信在发送端自上而下，在接收端自下而上依层进行；但也不一定要经过全七层，比如：中继器之间的连接只需要在物理层中进行，而路由器之间的连接只需通过下三层；
  - 但双方端端之间的通信必须是对等的，不可能存在不对等层次间的通信（也就是在发送端通过了哪些层，在接收端也要反序通过这些层）；

### TCP/IP模型

> OSI系统只是提供了网络通信的模型，实际应用中，我们使用的最成熟最广的互联协议是TCP/IP模型基础上建立的，它相对于OSI模型更为精简；
> TCP：传输控制协议（Transport Control Protocol)
> IP：Internet Protocol，网络协议
> UDP：User Datagram Protocol,用户数据包协议

**分为四层：**

- 网络访问层：对应OSI的物理层+数据链路层
- Internet层：对应OSI网络层
- 传输层：对应OSI的传输层
- 应用层：对应OSI的会话层、表示层、应用层

#### TCP的三次握手

- TCP的三次握手是为了保证数据通信时安全性，确保请求方与响应方是正确对应的。
- 通俗用一个发送机密文件的例子来理解：
  - 发送方为确保机密，先将文件上锁寄给接收方，接收方收到文件后再上一把自己的锁并将这个上过两次锁的文件再寄给发送方，发送方收到后将自己的锁解掉，再寄给接收方，这时接收方就可以收到只有自己的锁的文件了；
- 那么在TCP协议中，这个三次握手过程是怎么实现的？
  - **第一次握手**：请求方先发送位码：syn=1,随机产生seq number=200的数据包到响应方（服务器），这时接收方由syn=1得知发送方要求实现同步联机；
  - **第二次握手**：响应方收到请求联机后，要确认此信息，便向发送方发送ack number=(seq+1),syn=1,ack=1,再随机产生seq number=500的包；
  - **第三次握手**：发送方收到来自接收方的数据包，检查接收到的数据中`ack number`是不是与自己刚才发送的随机码`(seq nubmer+1)`相等，以及位码ack是不是为`1`，如果两项无误证明是自己需要的对方，便再发送`ack number=(刚收到来自响应方的seq number+1)`，`ack=1`，响应方确认`seq number`值无误与`ack=1`，便可以确认连接建立成功，三次握手完成。
  - **Note:**
    - 每一次握手只要需要对就方响应就会随机生成一个序列码：`seq number`,对方收到响应时便在这个序列码基础上进行加`1`，当作响应码`ack number`再返给原来请求方，这样一个过程来确保连接双方无误；
    - 同时，第一次发起请求同步有一个`syn=1`码，这是一个请求同步，发起请求的码；
    - 每次响应，不管是请求方在握手过程中响应响应方还是响应方响应请求，都会有一个`ack=1`码，来确认自己是在应答对方；

#### TCP的四次挥手

- TCP的四次挥手是指双方要关闭连接， 这时出现的情况可能是双方任一方发起close请求也可能是双方同时发起；
- 当其中一方发起关闭请求时：
  - **第一次挥手：**请求方发起一个`fin`用来关闭请求方给响应方的数据传送，这时请求方进入到`fin_wait`状态，同时肯定还是要发送随机生成的请求序号；
  - **第二次挥手：**响应方收到`fin`后，发送一个`ACK`给请求方，同时发送确认序号（为收到的请求序号+1），这个时候响应方进入到`CLOSE_WAIT`状态，同时要发送随机序号`seq`；
  - **第三次挥手：**响应方发送一个`FIN`，用来关闭响应方到请求方的数据传送，这时响应方进入到`LAST_ACK`状态，同时要发送随机序号`seq`；
  - **第四次挥手：**请求方收到`FIN`后，进入到`TIME_CLOSE`状态，再发送一个`ACK`给响应方，同时发送确认序号（在随机序号上+1），响应方收到这些信息确认无误，进行到`CLOSED`状态；完成四次挥手；
- 当双方同时发起关闭请求时：
  - **前两次挥手：**双方发送`FIN=1`码，与随机码；
  - **后两次挥手：**双方收到后，再给彼此发送`ACK=1`和`ack number=（随机码+1）`；
- **Note:**
  - `FIN`码发送后，相应的方应该进入到`WAIT`状态或`CLOSE`状态；
  - `ACK`响应码用来指示自己需要得到回复；
  - 还是与握手一样，用来确认双方信息连接的无误都通过随机序码指定的运算；
